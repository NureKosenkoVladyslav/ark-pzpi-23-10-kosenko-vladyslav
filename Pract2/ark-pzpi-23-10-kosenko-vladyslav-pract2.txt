Харківський національний університет радіоелектроніки Факультет комп’ютерних наук
Кафедра програмної інженерії






ЗВІТ
до практичного завдання № 2
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Основні методи рефакторингу для мови програмування Python»




Виконав ст. гр. ПЗПІ-23-10
       Косенко В.В




Перевірив ст. викладач катедри ПІ Сокорчук Ігор Петрович










Харків 2025
 
1 ІСТОРІЯ ЗМІН

23.10.25, версія 0.1 — створено розділ “Опис виконаної роботи”.
23.10.25, версія 0.1 — створено додаток А, додаток Б.
23.10.25, версія 0.1 — створено розділи “Історія змін”, “Завдання”, “Висновки”.
23.10.25, версія 0.1 — створено додаток В.   
2 ЗАВДАННЯ

Мета роботи — практичне дослідження та застосування трьох фундаментальних методів рефакторингу за класифікацією Мартіна Фаулера: Extract Method (Виділення методу), Rename Method (Перейменування методу) та Simplify Conditional Expression (Спрощення умовних виразів). На прикладах коду мовою Python демонструється процес виявлення «запахів коду» (занадто довгі методи, незрозуміла номенклатура, складна вкладеність умов) та їх усунення для покращення читабельності та архітектурної чистоти ПЗ.
 

 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
Вступ до рефакторингу коду   Моя робота присвячена темі практичного застосування методів рефакторингу для вдосконалення коду мовою Python. Це питання є критично важливим для сучасної програмної інженерії, адже з часом будь-який проєкт накопичує складність, що веде до появи «технічного боргу». Рефакторинг, за визначенням Мартіна Фаулера, — це процес зміни внутрішньої структури програмного забезпечення для полегшення розуміння коду та здешевлення його модифікації без зміни його зовнішньої поведінки. Python, завдяки своїй філософії «Simple is better than complex», є ідеальним середовищем для впровадження чистих архітектурних рішень, які ми розглянемо далі.  	

 3.2 Значення рефакторингу для якості програм   Системне вдосконалення коду — це передусім інструмент забезпечення стабільності та масштабованості продукту. Добре проведений рефакторинг підвищує читабельність програмної логіки, роблячи її «прозорою» для нових розробників. Це дозволяє швидше знаходити приховані дефекти та значно полегшує процес написання автоматизованих тестів. Крім того, охайний код знижує когнітивне навантаження на програміста, дозволяючи зосередитися на бізнес-логіці, а не на розплутуванні заплутаних конструкцій («спагеті-коду»).

  3.3 Метод Rename Method (Перейменування)   Одним із базових, але водночас найпотужніших методів є Rename Method. Суть його полягає у заміні неінформативних назв функцій та змінних на самодокументовані імена. У Python важливо дотримуватися стилю snake_case, але головне — назва має передавати намір автора. Наприклад, заміна абстрактного calc() на calculate_total_price() дозволяє зрозуміти зміст операції без вивчення її реалізації. Це усуває потребу в зайвих коментарях і робить код зрозумілим на рівні читання звичайної англійської мови.   

3.4 Метод Extract Method (Виділення методу)   Цей метод спрямований на боротьбу з «довгими методами», які виконують забагато завдань одночасно. Якщо фрагмент коду можна логічно згрупувати та назвати, його слід винести в окрему функцію. Це відповідає принципу єдиної відповідальності (Single Responsibility Principle). Виділення розрахунку знижки або форматування адреси в окремі підпрограми робить основний алгоритм високорівневим і лаконічним, що є ознакою професійного підходу до розробки.

  3.5 Метод Simplify Conditional Expression (Спрощення умов)   Складні вкладені умови (nested ifs) часто стають джерелом логічних помилок. Метод Simplify Conditional Expression пропонує використовувати логічні оператори або техніку «захисних клауз» (guard clauses) для випрямлення потоку виконання. У Python це часто реалізується через об’єднання умов або використання конструкції if-return на початку методу. Спрощення логіки дозволяє позбутися «піраміди смерті» та робить умови перевірки даних очевидними та однозначними.  

 3.6 Ідентифікація «запахів коду»   Ефективний рефакторинг неможливий без вміння розпізнавати симптоми поганого дизайну, які називають «запахами коду». До них належать дублювання логіки, занадто великі класи, довгі списки параметрів та «магічні числа». Виявлення цих ознак на ранніх етапах дозволяє вчасно провести реорганізацію, поки складність проєкту не стала критичною. Використання лінтерів, таких як Pylint або Flake8, допомагає автоматизувати процес пошуку таких проблемних місць.   
3.7 Принципи безпечного рефакторингу   Рефакторинг — це не хаотична зміна коду, а дисциплінована техніка. Головною умовою безпеки є наявність тестів: перед початком змін необхідно переконатися, що поточний функціонал працює коректно. Кожна зміна має бути мінімальною, після чого слідує запуск тестів. Такий ітеративний підхід гарантує, що покращення структури не призведе до регресійних помилок, а цілісність системи буде збережена на кожному етапі трансформації.  

 3.8 Висновки щодо архітектурної гігієни   Підсумовуючи, можна стверджувати, що методи рефакторингу Мартіна Фаулера є фундаментом для створення якісного програмного забезпечення. Вони перетворюють написання коду з механічного процесу на мистецтво створення гнучких і підтримуваних систем. Для розробника на Python володіння цими методами означає здатність писати код, який не просто працює «тут і зараз», а залишається життєздатним протягом багатьох років, легко адаптуючись до нових вимог і технологій.





































4 ВИСНОВКИ

Під час виконання практичної роботи було встановлено, що:
1.	Extract Method сприяє дотриманню принципу єдиної відповідальності.
2.	Rename Method критично важливий для командної розробки, оскільки зменшує час на ознайомлення з кодом.
3.	Simplify Conditional Expression робить логіку програми безпечнішою, зменшуючи ймовірність помилок у складних розгалуженнях. Рефакторинг є необхідною складовою життєвого циклу ПЗ, що дозволяє тримати «технічний борг» під контролем.


























5 ВИКОРИСТАНІ ДЖЕРЕЛА

1.  Фаулер М. Рефакторинг. Поліпшення дизайну існуючого коду. 2-ге вид. — 2018.
2.  Мартин Р. Чистий код. — 2019.
3.  Refactoring Guru [Електронний ресурс]. — Режим доступу: https://refactoring.guru/uk/
 
ДОДАТОК А
Відеозапис доповіді: https://youtu.be/zlmpjT91Hpw

Хронологія відеозапису:

00:00 - Вступ 
00:32 - Поняття рефакторингу 
01:14 - Причини необхідності рефакторингу 
01:58 - Обрані методи рефакторингу 
03:06 - Extract Method 
03:50 - Extract Method приклад коду 
04:30 - Rename Method 
05:00 - Rename Method приклад коду
05:25 - Simplify Conditional Experssion 
06:00 - Simplify Conditional Experssion приклад коду 
06:15 - Висновки 

























ДОДАТОК Б


 
Рисунок Б.1 — Титульний слайд







 
Рисунок Б.2 — Вступ



 

Рисунок Б.3 — Причини необхідності рефакторингу 

 
Рисунок Б.4 — Обрані методи рефакторингу


 

Рисунок Б.5 — Extract Method
 
 
Рисунок Б.6 — Extract Method – приклад коду



 
Рисунок Б.7 — Rename Method – опис проблеми
 

 
Рисунок Б.8 — Rename Method – Код до і після


 

Рисунок Б.9 — Simplify Conditional Experssion – Опис проблеми
 
 

Рисунок Б.10 — Simplify Conditional Experssion – Код до і після



 

Рисунок Б.11 — Висновки
 
ДОДАТОК В  Програмний код

В.1 Приклад оформлення та іменування (Метод Rename Method)

#Добре:

 def calculate_total_price(price: float, quantity: int) -> float:
   """
      Обчислює загальну вартість товару на основі ціни та кількості.
      """
     return price * quantity
 
  def main():
      item_price = 45.5
      item_quantity = 3
     total = calculate_total_price(item_price, item_quantity)
     print(f"Загальна сума: {total}")
 
 if __name__ == '__main__':
     main()

#Погано:

def calc(a,b):
return a*b
def main():
x=45.5; y=3; print('sum=',calc(x,y))
main()

В.2 Приклад декомпозиції та документування (Метод Extract Method)
   def calculate_discount(base_price: float) -> float:
       """
       Визначає суму знижки залежно від обсягу замовлення.
   
       Parameters:
           base_price (float): сума замовлення без знижки.
   
       Returns:
           float: сума нарахованої знижки (5% якщо сума > 1000, інакше 0).
      """
      if base_price > 1000:
          return base_price * 0.05
      return 0.0
  
  def process_order(price: float, quantity: int) -> float:
     """Обробляє замовлення: розраховує базу та віднімає знижку."""
      base_price = price * quantity
      discount = calculate_discount(base_price)
      total_sum = base_price - discount
      return round(total_sum, 2)

  В.3 Приклад спрощення логіки (Метод Simplify Conditional Expression)

  def is_user_active(user) -> bool:
       """
       Перевіряє, чи є користувач валідним та активним.
   
       Рішення: використано логічний оператор 'and' для усунення 
       вкладених умов (піраміди If).
       """
       return user is not None and user.is_active








 












 

